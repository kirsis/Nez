using System;
using Nez.BitmapFonts;
using Microsoft.Xna.Framework;
using System.Text;
using System.Collections.Generic;
using Microsoft.Xna.Framework.Input;
using System.Globalization;

namespace Nez.UI
{
	/// <summary>
	/// A single-line text input field.
	///
	/// The preferred height of a text field is the height of the {@link TextFieldStyle#font} and {@link TextFieldStyle#background}.
	/// The preferred width of a text field is 150, a relatively arbitrary size.
	///
	/// The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is
	/// pressed. Clipboard functionality is provided via the {@link Clipboard} interface.
	///
	/// The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events
	/// generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.
	/// The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard}
	/// implementation will bring up the default IME.
	/// </summary>
	public class TextField : Element, IInputListener, IKeyboardListener
	{
		public event Action<TextField, string> OnTextChanged;
		public event Action<TextField> OnEnterPressed = delegate { };
		public event Action<TextField> OnTabPressed = delegate { };

		public override float PreferredWidth => _preferredWidth;
		 
		public override float PreferredHeight
		{
			get
			{
				var prefHeight = TextHeight;
				if (style.Background != null)
					prefHeight = Math.Max(prefHeight + style.Background.BottomHeight + style.Background.TopHeight,
						style.Background.MinHeight);

					return prefHeight;
			}
		}

		/// <summary>
		/// the maximum distance outside the TextField the mouse can move when pressing it to cause it to be unfocused
		/// </summary>
		public float TextFieldBoundaryThreshold = 100f;

		/// <summary>
		/// if true and setText is called it will be ignored
		/// </summary>
		public bool ShouldIgnoreTextUpdatesWhileFocused = true;

		protected string text;
		protected int _cursor, _selectionStart;
		protected virtual int Cursor
		{
			get
			{
				return _cursor;
			}
			set
			{
				_cursor = value;
			}
		}
		protected virtual int SelectionStart
		{
			get
			{
				return _selectionStart;
			}
			set
			{
				_selectionStart = value;
			}
		}
		protected virtual bool HasSelection {
			get;
			set;
		}
		protected bool writeEnters;
		List<float> glyphPositions = new List<float>(15);

		float _preferredWidth = 150;
		TextFieldStyle style;
		protected string MessageText;
		protected string displayText = string.Empty;
		ITextFieldFilter filter;
		bool focusTraversal = true, onlyFontChars = true;
		protected bool Disabled;
		int textHAlign = AlignInternal.Left;
		protected float SelectionX, SelectionWidth;
		StringBuilder _textBuffer = new StringBuilder();

		bool passwordMode;
		StringBuilder passwordBuffer;
		char passwordCharacter = '*';

		protected float fontOffset, textOffset;
		protected float textHeight;
		protected virtual float TextHeight { get => textHeight; }
		protected float RenderOffset { get; set; } = 0.0f;
		protected int VisibleTextStart, VisibleTextEnd;
		int maxLength = 0;

		float blinkTime = 0.5f;
		protected bool CursorOn = true;
		float lastBlink;

		bool programmaticChangeEvents;

		protected bool _isOver, _isPressed, _isFocused;
		ITimer _keyRepeatTimer;
		float _keyRepeatTime = 0.2f;

		protected TextField() // dummy for childclasses
		{
		}

		public TextField(string text, TextFieldStyle style)
		{
			SetStyle(style);
			SetText(text);
			SetSize(PreferredWidth, PreferredHeight);
		}


		public TextField(string text, Skin skin, string styleName = null) : this(text,
			skin.Get<TextFieldStyle>(styleName))
		{ }


		#region IInputListener

		float _clickCountInterval = 0.2f;
		int _clickCount;
		float _lastClickTime;

		void IInputListener.OnMouseEnter()
		{
			_isOver = true;
		}


		void IInputListener.OnMouseExit()
		{
			_isOver = _isPressed = false;
		}


		bool IInputListener.OnMousePressed(Vector2 mousePos)
		{
			return OnMousePressed(mousePos);
		}

		protected virtual bool OnMousePressed(Vector2 mousePos)
		{
			if (Disabled)
				return false;

			_isPressed = true;
			SetCursorPosition(mousePos.X, mousePos.Y);
			SelectionStart = Cursor;
			HasSelection = true;
			var stage = GetStage();
			if (stage != null)
				stage.SetKeyboardFocus(this as IKeyboardListener);

			return true;
		}


		void IInputListener.OnMouseMoved(Vector2 mousePos)
		{
			if (DistanceOutsideBoundsToPoint(mousePos) > TextFieldBoundaryThreshold)
			{
				_isPressed = _isOver = false;
				GetStage().RemoveInputFocusListener(this);
			}
			else
			{
				SetCursorPosition(mousePos.X, mousePos.Y);
			}
		}


		void IInputListener.OnMouseUp(Vector2 mousePos)
		{
			if (SelectionStart == Cursor)
				HasSelection = false;

			if (Time.TotalTime - _lastClickTime > _clickCountInterval)
				_clickCount = 0;
			_clickCount++;
			_lastClickTime = Time.TotalTime;
			_isPressed = _isOver = false;
		}


		bool IInputListener.OnMouseScrolled(int mouseWheelDelta)
		{
			return false;
		}

		#endregion


		#region IKeyboardListener

		void IKeyboardListener.KeyDown(Keys key)
		{
			if (Disabled)
				return;

			lastBlink = 0;
			CursorOn = false;

			var isCtrlDown = InputUtils.IsControlDown();
			var jump = isCtrlDown && !passwordMode;
			var repeat = false;

			if (isCtrlDown)
			{
				if (key == Keys.V)
				{
					Paste(Clipboard.GetContents(), true);
				}
				else if (key == Keys.C || key == Keys.Insert)
				{
					Copy();
					return;
				}
				else if (key == Keys.X)
				{
					Cut(true);
					return;
				}
				else if (key == Keys.A)
				{
					SelectAll();
					return;
				}
			}

			if (InputUtils.IsShiftDown())
			{
				if (key == Keys.Insert)
					Paste(Clipboard.GetContents(), true);
				else if (key == Keys.Delete)
					Cut(true);

				// jumping around shortcuts
				var temp = Cursor;
				var foundJumpKey = true;

				if (key == Keys.Left)
				{
					MoveCursor(false, jump);
					repeat = true;
				}
				else if (key == Keys.Right)
				{
					MoveCursor(true, jump);
					repeat = true;
				}
				else if (key == Keys.Home)
				{
					GoHome();
				}
				else if (key == Keys.End)
				{
					GoEnd();
				}
				else
				{
					foundJumpKey = false;
				}

				if (foundJumpKey && !HasSelection)
				{
					SelectionStart = temp;
					HasSelection = true;
				}
			}
			else
			{
				// Cursor movement or other keys (kills selection)
				if (key == Keys.Left)
				{
					if (HasSelection)
					{
						Cursor = Math.Min(Cursor, SelectionStart);
						ClearSelection();
					} else
					{
						MoveCursor(false, jump);
					}

					repeat = true;
				}
				else if (key == Keys.Right)
				{
					if (HasSelection)
					{
						Cursor = Math.Max(Cursor, SelectionStart);
						ClearSelection();
					}
					else
					{
						MoveCursor(true, jump);
					}
					repeat = true;
				}
				else if (key == Keys.Home)
				{
					GoHome();
				}
				else if (key == Keys.End)
				{
					GoEnd();
				}
			}

			Cursor = Mathf.Clamp(Cursor, 0, GetComposedLength(text));

			if (repeat)
			{
				if (_keyRepeatTimer != null)
					_keyRepeatTimer.Stop();
				_keyRepeatTimer = Core.Schedule(_keyRepeatTime, true, this,
					t => (t.Context as IKeyboardListener).KeyDown(key));
			}
		}

		protected virtual int GetComposedLength(string text)
		{
			return text?.Length ?? 0;
		}

		void IKeyboardListener.KeyPressed(Keys key, char character)
		{
			this.KeyPressed(key, character);
		}

		protected void KeyPressed(Keys key, char character)
		{
			if (InputUtils.IsControlDown())
				return;

			// disallow typing most ASCII control characters, which would show up as a space
			switch (key)
			{
				case Keys.Back:
				case Keys.Delete:
				case Keys.Tab:
				case Keys.Enter:
					break;
				default:
					{
						if ((int)character < 32)
							return;

						break;
					}
			}

			if (key == Keys.Tab && focusTraversal)
			{
				Next(InputUtils.IsShiftDown());
			}
			else
			{
				var enterPressed = key == Keys.Enter;
				var backspacePressed = key == Keys.Back;
				var deletePressed = key == Keys.Delete;
				var tabPressed = key == Keys.Tab;
				var add = enterPressed ? writeEnters : (!onlyFontChars || style.Font.HasCharacter(character));
				var remove = backspacePressed || deletePressed;

				if (tabPressed)
					OnTabPressed(this);

				if (enterPressed)
					OnEnterPressed(this);

				if (add || remove)
				{
					var oldText = text;
					if (HasSelection)
					{
						Cursor = Delete(false);
					}
					else
					{
						if (backspacePressed && Cursor > 0)
						{
							var te = GetComposedLength(text);
							text = SafeSubstringByTextElements(text, 0, Cursor - 1) + SafeSubstringByTextElements(text, Cursor--);
							RenderOffset = 0;
						}

						if (deletePressed && Cursor < GetComposedLength(text))
						{
							text = SafeSubstringByTextElements(text, 0, Cursor) + SafeSubstringByTextElements(text, Cursor + 1);
						}
					}

					if (add && !remove)
					{
						// character may be added to the text.
						if (!enterPressed)
							return;

						if (!WithinMaxLength(GetComposedLength(text)))
							return;

						text = Insert(Cursor++, "\n", text);
					}

					ChangeText(oldText, text);
					UpdateDisplayText();
				}
			}
		}

		protected virtual string SafeSubstringByTextElements(string text, int startIndex, int length)
		{
			return text.Substring(startIndex, length);
		}

		protected virtual string SafeSubstringByTextElements(string text, int startIndex)
		{
			return text.Substring(startIndex);
		}

		void IKeyboardListener.KeyReleased(Keys key)
		{
			if (_keyRepeatTimer != null)
			{
				_keyRepeatTimer.Stop();
				_keyRepeatTimer = null;
			}
		}


		void IKeyboardListener.GainedFocus()
		{
			OnGainedFocus();
		}

		protected virtual void OnGainedFocus()
		{
			HasSelection = _isFocused = true;
		}


		void IKeyboardListener.LostFocus()
		{
			OnLostFocus();
		}

		protected virtual void OnLostFocus()
		{
			HasSelection = _isFocused = false;
			if (_keyRepeatTimer != null)
			{
				_keyRepeatTimer.Stop();
				_keyRepeatTimer = null;
			}
		}

		#endregion


		protected virtual int LetterUnderCursor(float x, float y)
		{
			System.Diagnostics.Debug.WriteLine($"Letter under {x}");
			var halfSpaceSize = style.Font.DefaultCharacter.Bounds.Width + style.Font.DefaultCharacter.XAdvance;
			x -= textOffset + fontOffset + halfSpaceSize /*- style.font.getData().cursorX*/ -
				 GetPositionTo(VisibleTextStart);
			var n = GetComposedLength(text) + 1;// glyphPositions.Count;
			for (var i = 0; i < n; i++)
			{
				if (GetPositionTo(i) > x && i >= 1)
				{
					if (GetPositionTo(i) - x <= x - GetPositionTo(i - 1))
						return i;

					return i - 1;
				}
			}

			return n - 1;
		}


		protected bool IsWordCharacter(char c)
		{
			return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');
		}


		protected int[] WordUnderCursor(int at)
		{
			int start = at, right = GetComposedLength(text), left = 0, index = start;
			for (; index < right; index++)
			{
				if (!IsWordCharacter(text[index]))
				{
					right = index;
					break;
				}
			}

			for (index = start - 1; index > -1; index--)
			{
				if (!IsWordCharacter(text[index]))
				{
					left = index + 1;
					break;
				}
			}

			return new int[] { left, right };
		}


		int[] WordUnderCursor(float x, float y)
		{
			return WordUnderCursor(LetterUnderCursor(x, y));
		}


		bool WithinMaxLength(int size)
		{
			return maxLength <= 0 || size < maxLength;
		}


		public TextField SetMaxLength(int maxLength)
		{
			this.maxLength = maxLength;
			return this;
		}


		public int GetMaxLength()
		{
			return maxLength;
		}


		/// <summary>
		/// When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.
		/// When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
		/// when typed or pasted.
		/// </summary>
		/// <param name="onlyFontChars">If set to <c>true</c> only font chars.</param>
		public TextField SetOnlyFontChars(bool onlyFontChars)
		{
			this.onlyFontChars = onlyFontChars;
			return this;
		}


		public virtual TextField SetStyle(TextFieldStyle style)
		{
			this.style = style;
			textHeight = style.Font.LineHeight;
			InvalidateHierarchy();
			return this;
		}


		/// <summary>
		/// Returns the text field's style. Modifying the returned style may not have an effect until {@link #setStyle(TextFieldStyle)} is called
		/// </summary>
		/// <returns>The style.</returns>
		public TextFieldStyle GetStyle()
		{
			return style;
		}

		protected virtual float GetVisibleWidth()
		{
			float visibleWidth = GetWidth();
			if (style.Background != null)
				visibleWidth -= style.Background.LeftWidth + style.Background.RightWidth;
			return visibleWidth;
		}

		protected void CalculateOffsets()
		{
			//CalculateOffsets_New(); return;
			float visibleWidth = GetWidth();
			if (style.Background != null)
				visibleWidth -= style.Background.LeftWidth + style.Background.RightWidth;

			var positionCount = GetComposedLength(text) + 1; // +1 to account for positioning after the text
			
			// Check if the cursor has gone out the left or right side of the visible area and adjust renderoffset.
			var distance = GetPositionTo(Math.Max(0, Cursor - 1)) + RenderOffset;
			if (distance <= 0)
			{
				RenderOffset -= distance;
			}
			else
			{
				var index = Math.Min(positionCount - 1, Cursor + 1);
				var minX = GetPositionTo(index) - visibleWidth;
				if (-RenderOffset < minX)
				{
					RenderOffset = -minX;
				}
			}

			// calculate first visible char based on render offset
			VisibleTextStart = 0;
			var startX = 0f;
			for (var i = 0; i < positionCount; i++)
			{
				var posToI = GetPositionTo(i);
				if (posToI >= -RenderOffset)
				{
					VisibleTextStart = Math.Max(0, i);
					startX = posToI;
					break;
				}
			}

			// calculate last visible char based on visible width and render offset
			var length = displayText.Length;
			VisibleTextEnd = Math.Min(length, Cursor + 1);
			for (; VisibleTextEnd <= length; VisibleTextEnd++)
				if (GetPositionTo(VisibleTextEnd) > startX + visibleWidth)
				{
					break;
				}

			VisibleTextEnd = Math.Max(0, VisibleTextEnd - 1);

			if ((textHAlign & AlignInternal.Left) == 0)
			{
				textOffset = visibleWidth - (GetPositionTo(VisibleTextEnd) - startX);
				if ((textHAlign & AlignInternal.Center) != 0)
					textOffset = Mathf.Round(textOffset * 0.5f);
			}
			else
			{
				textOffset = startX + RenderOffset;
			}

			// calculate selection x position and width
			if (HasSelection)
			{
				var minIndex = Math.Min(Cursor, SelectionStart);
				var maxIndex = Math.Max(Cursor, SelectionStart);
				var minX = Math.Max(GetPositionTo(minIndex), -RenderOffset);
				var maxX = Math.Min(GetPositionTo(maxIndex), visibleWidth - RenderOffset);
				SelectionX = minX;

				if (RenderOffset == 0)
					SelectionX += textOffset;

				SelectionWidth = maxX - minX;
			}
		}


		#region Drawing

		public override void Draw(Batcher batcher, float parentAlpha)
		{
			var font = style.Font;
			var fontColor = this.GetFontColor();
			IDrawable selection = style.Selection;
			var background = this.GetBackgroundDrawable();
			
			var color = GetColor();
			var x = GetX();
			var y = GetY();
			var width = GetWidth();
			var height = GetHeight();
			var bgLeftWidth = background?.LeftWidth ?? 0;

			this.DrawBackgroundIfNeeded(batcher, background, parentAlpha);

			var textY = GetTextY(font, background);
			var yOffset = (textY < 0) ? -textY - font.LineHeight / 2f + GetHeight() / 2 : 0;
			CalculateOffsets();

			if (_isFocused && HasSelection && selection != null)
				DrawSelection(selection, batcher, font, x + bgLeftWidth, y + textY + yOffset);

			if (GetComposedLength(displayText) == 0)
			{
				if (!_isFocused && MessageText != null)
				{
					var messageFontColor = GetMessageFontColor(parentAlpha);
					var messageFont = GetMessageFont(); 
					batcher.DrawString(messageFont, MessageText,
						new Vector2(x + bgLeftWidth, y + textY + yOffset), messageFontColor);

					//messageFont.draw( batcher.batcher, messageText, x + bgLeftWidth, y + textY + yOffset, 0, messageText.length(),
					//	width - bgLeftWidth - bgRightWidth, textHAlign, false, "..." );
				}
			}
			else
			{
				var col = ColorExt.Create(fontColor, (int)(fontColor.A * parentAlpha));
				var t = SafeSubstringByTextElements(displayText, VisibleTextStart, VisibleTextEnd - VisibleTextStart);
				batcher.DrawString(font, t, new Vector2(x + bgLeftWidth + textOffset, y + textY + yOffset),
					col);
			}

			if (_isFocused && !Disabled)
			{
				Blink();
				if (CursorOn && style.Cursor != null)
					DrawCursor(style.Cursor, batcher, font, x + bgLeftWidth, y + textY + yOffset);
			}
		}

		protected BitmapFont GetMessageFont()
		{
			return style.MessageFont != null ? style.MessageFont : style.Font;
		}

		protected IDrawable? GetBackgroundDrawable()
		{
			return (Disabled && style.DisabledBackground != null)
				? style.DisabledBackground
				: ((_isFocused && style.FocusedBackground != null) ? style.FocusedBackground : style.Background);
		}

		protected void DrawBackgroundIfNeeded(Batcher batcher, IDrawable background, float parentAlpha)
		{
			if (background != null)
			{
				background.Draw(batcher, x, y, width, height, ColorExt.Create(color, (int)(color.A * parentAlpha)));
			}
		}

		protected Color GetFontColor()
		{
			// TODO: disabled and isFocused should refresh _texture
			return (Disabled && style.DisabledFontColor.HasValue)
			   ? style.DisabledFontColor.Value
			   : ((_isFocused && style.FocusedFontColor.HasValue) ? style.FocusedFontColor.Value : style.FontColor);
		}

		protected Color GetMessageFontColor(float parentAlpha)
		{
			return style.MessageFontColor.HasValue
						? style.MessageFontColor.Value
						: new Color(180, 180, 180, (int)(color.A * parentAlpha)); 
		}

		protected float GetTextY(BitmapFont font, IDrawable background)
		{
			float height = GetHeight();
			float textY = TextHeight / 2 + font.Padding.Bottom;
			if (background != null)
			{
				var bottom = background.BottomHeight;
				textY = textY - (height - background.TopHeight - bottom) / 2 + bottom;
			}
			else
			{
				textY = textY - height / 2;
			}

			return textY;
		}


		/// <summary>
		/// Draws selection rectangle
		/// </summary>
		/// <param name="selection">Selection.</param>
		/// <param name="batch">Batch.</param>
		/// <param name="font">Font.</param>
		/// <param name="x">The x coordinate.</param>
		/// <param name="y">The y coordinate.</param>
		protected void DrawSelection(IDrawable selection, Batcher batcher, BitmapFont font, float x, float y)
		{
			selection.Draw(batcher, x + SelectionX + RenderOffset + fontOffset, y - font.Padding.Bottom / 2,
				SelectionWidth, TextHeight, Color.White);
		}


		protected void DrawCursor(IDrawable cursorPatch, Batcher batcher, BitmapFont font, float x, float y)
		{
			cursorPatch.Draw(batcher,
				x + textOffset + GetPositionTo(Cursor) - GetPositionTo(VisibleTextStart) + fontOffset -
				1 /*font.getData().cursorX*/,
				y - font.Padding.Bottom / 2, cursorPatch.MinWidth, TextHeight, color);
		}

		protected virtual float GetPositionTo(int index)
		{
			try
			{
				return glyphPositions[index];
			} catch (ArgumentOutOfRangeException)
			{
				throw;
			}
		}

		#endregion


		void UpdateDisplayText()
		{
			var textLength = GetComposedLength(text);

			_textBuffer.Clear();
			for (var i = 0; i < textLength; i++)
			{
				var c = text[i];
				_textBuffer.Append(style.Font.HasCharacter(c) ? c : ' ');
			}

			var newDisplayText = _textBuffer.ToString();

			if (passwordMode && style.Font.HasCharacter(passwordCharacter))
			{
				if (passwordBuffer == null)
					passwordBuffer = new StringBuilder(newDisplayText.Length);
				else if (passwordBuffer.Length > textLength)
					passwordBuffer.Clear();

				for (var i = passwordBuffer.Length; i < textLength; i++)
					passwordBuffer.Append(passwordCharacter);
				displayText = passwordBuffer.ToString();
			}
			else
			{
				displayText = newDisplayText;
			}

			//layout.setText( font, displayText );
			glyphPositions.Clear();
			float x = 0;
			if (GetComposedLength(displayText) > 0)
			{
				for (var i = 0; i < GetComposedLength(displayText); i++)
				{
					var region = style.Font[displayText[i]];

					// we dont have fontOffset in BitmapFont, it is the first Glyph in a GlyphRun
					//if( i == 0 )
					//	fontOffset = region.xAdvance;
					glyphPositions.Add(x);
					x += region.XAdvance;
				}

				//GlyphRun run = layout.runs.first();
				//FloatArray xAdvances = run.xAdvances;
				//fontOffset = xAdvances.first();
				//for( int i = 1, n = xAdvances.size; i < n; i++ )
				//{
				//	glyphPositions.add( x );
				//	x += xAdvances.get( i );
				//}
			}
			else
			{
				fontOffset = 0;
			}

			glyphPositions.Add(x);

			if (SelectionStart > GetComposedLength(newDisplayText))
				SelectionStart = textLength;
		}


		protected void Blink()
		{
			if ((Time.TotalTime - lastBlink) > blinkTime)
			{
				CursorOn = !CursorOn;
				lastBlink = Time.TotalTime;
			}
		}


		#region Text manipulation

		/// <summary>
		/// Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField
		/// </summary>
		public void Copy()
		{
			if (HasSelection && !passwordMode)
			{
				var start = Math.Min(Cursor, SelectionStart);
				var length = Math.Max(Cursor, SelectionStart) - start;
				Clipboard.SetContents(SafeSubstringByTextElements(text, start, length));
			}
		}


		/// <summary>
		/// Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes it
		/// </summary>
		public void Cut()
		{
			Cut(programmaticChangeEvents);
		}


		void Cut(bool fireChangeEvent)
		{
			if (HasSelection && !passwordMode)
			{
				Copy();
				Cursor = Delete(fireChangeEvent);
				UpdateDisplayText();
			}
		}


		void Paste(string content, bool fireChangeEvent)
		{
			if (content == null)
				return;

			_textBuffer.Clear();
			int textLength = GetComposedLength(text);
			if (HasSelection)
				textLength -= Math.Abs(Cursor - SelectionStart);

			//var data = style.font.getData();
			for (int i = 0, n = content.Length; i < n; i++)
			{
				if (!WithinMaxLength(textLength + _textBuffer.Length))
					break;

				var c = content[i];
				if (!(writeEnters && c == '\r'))
				{
					if (onlyFontChars && !style.Font.HasCharacter(c))
						continue;

					if (filter != null && !filter.AcceptChar(this, c))
						continue;
				}

				_textBuffer.Append(c);
			}

			content = _textBuffer.ToString();

			if (HasSelection)
				Cursor = Delete(fireChangeEvent);
			if (fireChangeEvent)
				ChangeText(text, Insert(Cursor, content, text));
			else
				text = Insert(Cursor, content, text);
			UpdateDisplayText();
			Cursor += GetComposedLength(content);
		}


		string Insert(int position, string text, string to)
		{
			if (to.Length == 0)
				return text;

			return SafeSubstringByTextElements(to, 0, position) + text + SafeSubstringByTextElements(to, position, GetComposedLength(to) - position);
		}


		int Delete(bool fireChangeEvent)
		{
			try
			{
				var from = SelectionStart;
				var to = Cursor;
				var minIndex = Math.Min(from, to);
				var maxIndex = Math.Max(from, to);
				var newText = (minIndex > 0 ? SafeSubstringByTextElements(text, 0, minIndex) : string.Empty)
							  + (maxIndex < GetComposedLength(text) ? SafeSubstringByTextElements(text, maxIndex, GetComposedLength(text) - maxIndex) : string.Empty);

				if (fireChangeEvent)
					ChangeText(text, newText);
				else
					text = newText;

				ClearSelection();
				return minIndex;
			}
			catch (ArgumentOutOfRangeException)
			{
				throw;
			}
		}


		/// <summary>
		/// Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage
		/// up: If true, the TextField with the same or next smallest y coordinate is found, else the next highest.
		/// </summary>
		/// <param name="up">Up.</param>
		public virtual void Next(bool up)
		{
			var stage = GetStage();
			if (stage == null)
				return;

			var tmp2 = Vector2.Zero;
			var tmp1 = GetParent().LocalToStageCoordinates(new Vector2(GetX(), GetY()));
			var textField = FindNextTextField(stage.GetElements(), null, tmp2, tmp1, up);
			if (textField == null)
			{
				// Try to wrap around.
				if (up)
					tmp1 = new Vector2(float.MinValue, float.MinValue);
				else
					tmp1 = new Vector2(float.MaxValue, float.MaxValue);
				textField = FindNextTextField(GetStage().GetElements(), null, tmp2, tmp1, up);
			}

			if (textField != null)
				stage.SetKeyboardFocus(textField);
		}


		TextField FindNextTextField(List<Element> elements, TextField best, Vector2 bestCoords, Vector2 currentCoords,
									bool up)
		{
			bestCoords = Vector2.Zero;
			for (int i = 0, n = elements.Count; i < n; i++)
			{
				var element = elements[i];
				if (element == this)
					continue;

				if (element is TextField)
				{
					var textField = (TextField)element;
					if (textField.IsDisabled() || !textField.focusTraversal)
						continue;

					var elementCoords = element.GetParent()
						.LocalToStageCoordinates(new Vector2(element.GetX(), element.GetY()));
					if ((elementCoords.Y < currentCoords.Y ||
						 (elementCoords.Y == currentCoords.Y && elementCoords.X > currentCoords.X)) ^ up)
					{
						if (best == null
							|| (elementCoords.Y > bestCoords.Y ||
								(elementCoords.Y == bestCoords.Y && elementCoords.X < bestCoords.X)) ^ up)
						{
							best = (TextField)element;
							bestCoords = elementCoords;
						}
					}
				}
				else if (element is Group)
				{
					best = FindNextTextField(((Group)element).GetChildren(), best, bestCoords, currentCoords, up);
				}
			}

			return best;
		}

		#endregion


		/// <summary>
		/// if str is null, "" is used
		/// </summary>
		/// <param name="str">String.</param>
		public void AppendText(string str)
		{
			if (ShouldIgnoreTextUpdatesWhileFocused && _isFocused)
				return;

			if (str == null)
				str = "";

			ClearSelection();
			Cursor = text.Length;
			Paste(str, programmaticChangeEvents);
		}


		/// <summary>
		/// str If null, "" is used
		/// </summary>
		/// <param name="str">String.</param>
		public virtual TextField SetText(string str)
		{
			if (ShouldIgnoreTextUpdatesWhileFocused && _isFocused)
				return this;

			if (str == null)
				str = "";
			if (str == text)
				return this;

			ClearSelection();
			var oldText = text;
			text = "";
			Paste(str, false);
			if (programmaticChangeEvents)
				ChangeText(oldText, text);
			Cursor = 0;

			return this;
		}


		/// <summary>
		/// force sets the text without validating or firing change events. Use at your own risk.
		/// </summary>
		/// <param name="str">String.</param>
		public TextField SetTextForced(string str)
		{
			text = str;
			UpdateDisplayText();

			// ensure our cursor is in bounds
			Cursor = text.Length;

			return this;
		}


		/// <summary>
		/// Never null, might be an empty string
		/// </summary>
		/// <returns>The text.</returns>
		public string GetText()
		{
			return text;
		}


		/// <summary>
		/// oldText May be null
		/// </summary>
		/// <param name="oldText">Old text.</param>
		/// <param name="newText">New text.</param>
		protected virtual void ChangeText(string oldText, string newText)
		{
			if (newText == oldText)
				return;

			text = newText;

			if (OnTextChanged != null)
				OnTextChanged(this, text);
		}


		/// <summary>
		/// If false, methods that change the text will not fire {@link onTextChanged}, the event will be fired only when user changes the text
		/// </summary>
		/// <param name="programmaticChangeEvents">If set to <c>true</c> programmatic change events.</param>
		public TextField SetProgrammaticChangeEvents(bool programmaticChangeEvents)
		{
			this.programmaticChangeEvents = programmaticChangeEvents;
			return this;
		}


		public int GetSelectionStart()
		{
			return SelectionStart;
		}


		public string GetSelection()
		{
			return HasSelection
				? SafeSubstringByTextElements(text, Math.Min(SelectionStart, Cursor), Math.Max(SelectionStart, Cursor))
				: "";
		}


		/// <summary>
		/// Sets the selected text
		/// </summary>
		/// <param name="selectionStart">Selection start.</param>
		/// <param name="selectionEnd">Selection end.</param>
		public TextField SetSelection(int selectionStart, int selectionEnd)
		{
			Insist.IsFalse(selectionStart < 0, "selectionStart must be >= 0");
			Insist.IsFalse(selectionEnd < 0, "selectionEnd must be >= 0");

			selectionStart = Math.Min(text.Length, selectionStart);
			selectionEnd = Math.Min(text.Length, selectionEnd);
			if (selectionEnd == selectionStart)
			{
				ClearSelection();
				return this;
			}

			if (selectionEnd < selectionStart)
			{
				int temp = selectionEnd;
				selectionEnd = selectionStart;
				selectionStart = temp;
			}

			HasSelection = true;
			this.SelectionStart = selectionStart;
			Cursor = selectionEnd;

			return this;
		}


		public void SelectAll()
		{
			SetSelection(0, GetComposedLength(text));
		}


		public void ClearSelection()
		{
			HasSelection = false;
		}


		protected void SetCursorPosition(float x, float y)
		{
			lastBlink = 0;
			CursorOn = false;
			Cursor = LetterUnderCursor(x, y);
		}


		/// <summary>
		/// Sets the cursor position and clears any selection
		/// </summary>
		/// <param name="cursorPosition">Cursor position.</param>
		public TextField SetCursorPosition(int cursorPosition)
		{
			Insist.IsFalse(cursorPosition < 0, "cursorPosition must be >= 0");
			ClearSelection();
			Cursor = Math.Min(cursorPosition, text.Length);
			return this;
		}


		public int GetCursorPosition()
		{
			return Cursor;
		}


		protected void GoHome()
		{
			Cursor = 0;
		}


		protected void GoEnd()
		{
			Cursor = text.Length;
		}


		protected void MoveCursor(bool forward, bool jump)
		{
			var limit = forward ? text.Length : 0;
			var charOffset = forward ? 0 : -1;

			if ((forward && Cursor == limit) || (!forward && Cursor == 0))
				return;

			while ((forward ? ++Cursor < limit : --Cursor > limit) && jump)
			{
				if (!ContinueCursor(Cursor, charOffset))
					break;
			}
		}


		protected bool ContinueCursor(int index, int offset)
		{
			var c = text[index + offset];
			return IsWordCharacter(c);
		}


		#region Configuration

		public TextField SetPreferredWidth(float preferredWidth)
		{
			_preferredWidth = preferredWidth;
			return this;
		}


		/// <summary>
		/// filter May be null
		/// </summary>
		/// <param name="filter">Filter.</param>
		public TextField SetTextFieldFilter(ITextFieldFilter filter)
		{
			this.filter = filter;
			return this;
		}


		public ITextFieldFilter GetTextFieldFilter()
		{
			return filter;
		}


		/// <summary>
		/// If true (the default), tab/shift+tab will move to the next text field
		/// </summary>
		/// <param name="focusTraversal">If set to <c>true</c> focus traversal.</param>
		public TextField SetFocusTraversal(bool focusTraversal)
		{
			this.focusTraversal = focusTraversal;
			return this;
		}


		/// <summary>
		/// May be null
		/// </summary>
		/// <returns>The message text.</returns>
		public string GetMessageText()
		{
			return MessageText;
		}


		/// <summary>
		/// Sets the text that will be drawn in the text field if no text has been entered.
		/// </summary>
		/// <param name="messageText">Message text.</param>
		public virtual TextField SetMessageText(string messageText)
		{
			this.MessageText = messageText;
			return this;
		}


		/// <summary>
		/// Sets text horizontal alignment (left, center or right).
		/// </summary>
		/// <param name="alignment">Alignment.</param>
		public TextField SetAlignment(Align alignment)
		{
			textHAlign = (int)alignment;
			return this;
		}

		/// <summary>
		/// Gets text horizontal alignment (left, center or right).
		/// </summary>
		public Align GetAlignment()
		{
			return (Align)textHAlign;
		}


		/// <summary>
		/// If true, the text in this text field will be shown as bullet characters.
		/// </summary>
		/// <param name="passwordMode">Password mode.</param>
		public TextField SetPasswordMode(bool passwordMode)
		{
			this.passwordMode = passwordMode;
			UpdateDisplayText();
			return this;
		}


		public bool IsPasswordMode()
		{
			return passwordMode;
		}


		/// <summary>
		/// Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149 (bullet)
		/// </summary>
		/// <param name="passwordCharacter">Password character.</param>
		public TextField SetPasswordCharacter(char passwordCharacter)
		{
			this.passwordCharacter = passwordCharacter;
			if (passwordMode)
				UpdateDisplayText();
			return this;
		}


		public TextField SetBlinkTime(float blinkTime)
		{
			this.blinkTime = blinkTime;
			return this;
		}


		public TextField SetDisabled(bool disabled)
		{
			this.Disabled = disabled;
			return this;
		}


		public bool IsDisabled()
		{
			return Disabled;
		}

		public void NewCharactersAvailable(IList<string> charBuffer)
		{
			if (charBuffer.Count < 1) { return; }
			var oldText = this.text;

			if (HasSelection)
			{
				Cursor = Delete(false);
			}
			this.text = Insert(Cursor, string.Join(string.Empty, charBuffer), this.text);
			Cursor += charBuffer.Count;

			ChangeText(oldText, this.text);
			UpdateDisplayText();
		}

		#endregion


		/// <summary>
		/// Interface for filtering characters entered into the text field.
		/// </summary>
		public interface ITextFieldFilter
		{
			bool AcceptChar(TextField textField, char c);
		}
	}


	public class TextFieldStyle
	{
		public BitmapFont Font;

		public Color FontColor = Color.White;

		/** Optional. */
		public Color? FocusedFontColor, DisabledFontColor;

		/** Optional. */
		public IDrawable Background, FocusedBackground, DisabledBackground, Cursor, Selection;

		/** Optional. */
		public BitmapFont MessageFont;

		/** Optional. */
		public Color? MessageFontColor;


		public TextFieldStyle()
		{
			Font = Graphics.Instance.BitmapFont;
		}


		public TextFieldStyle(BitmapFont font, Color fontColor, IDrawable cursor, IDrawable selection,
							  IDrawable background)
		{
			Background = background;
			Cursor = cursor;
			Font = font ?? Graphics.Instance.BitmapFont;
			FontColor = fontColor;
			Selection = selection;
		}


		public static TextFieldStyle Create(Color fontColor, Color cursorColor, Color selectionColor,
											Color backgroundColor)
		{
			var cursor = new PrimitiveDrawable(cursorColor);
			cursor.MinWidth = 1;
			cursor.LeftWidth = 4;

			var background = new PrimitiveDrawable(backgroundColor);
			background.LeftWidth = background.RightWidth = 10f;
			background.BottomHeight = background.TopHeight = 5f;

			return new TextFieldStyle
			{
				FontColor = fontColor,
				Cursor = cursor,
				Selection = new PrimitiveDrawable(selectionColor),
				Background = background
			};
		}


		public TextFieldStyle Clone()
		{
			return new TextFieldStyle
			{
				Font = Font,
				FontColor = FontColor,
				FocusedFontColor = FocusedFontColor,
				DisabledFontColor = DisabledFontColor,
				Background = Background,
				FocusedBackground = FocusedBackground,
				DisabledBackground = DisabledBackground,
				Cursor = Cursor,
				Selection = Selection,
				MessageFont = MessageFont,
				MessageFontColor = MessageFontColor
			};
		}
	}


	public class DigitsOnlyFilter : TextField.ITextFieldFilter
	{
		public bool AcceptChar(TextField textField, char c)
		{
			return Char.IsDigit(c) || c == '-';
		}
	}


	public class FloatFilter : TextField.ITextFieldFilter
	{
		public bool AcceptChar(TextField textField, char c)
		{
			// only allow one .
			if (c == '.')
				return !textField.GetText().Contains(".");

			return Char.IsDigit(c) || c == '-';
		}
	}


	public class BoolFilter : TextField.ITextFieldFilter
	{
		public bool AcceptChar(TextField textField, char c)
		{
			if (c == 't' || c == 'T')
				textField.SetTextForced("true");

			if (c == 'f' || c == 'F')
				textField.SetTextForced("false");

			return false;
		}
	}
}